import numpy as np
from typing import List, Tuple


def generate_simplex(dimension: int, steps: int) -> 'np.ndarray':
    """
    Generates an array of uniformly spaced grid points on the unit simplex in a
    given dimension and under a specified level of coarseness.

    The generation is completely deterministic; given a fixed input
    specification, the function always returns the same result.

    This solution always selects the simplex vertices of the form

        v_i = (0, ..., 0, i, 0, ..., 0)  # 1 in the ith coordinate

    and computes the spacing so that the remaining points lie on a uniform
    lattice between the vertices.

    In full generality, the solution is necessarily primitive recursive.

    Params
    ------
    dimension:    float
                  The number of coordinates for each point. In other words, the
                  dimension of the space in which the simplex inhabits. E.g.,
                  the unit simplex in R^3, the triangle, corresponds to
                  dimension=3.
    steps:        int
                  The number of points to be spaced evenly between vertices of
                  the unit simplex. This works like numpy.linspace.

    Return
    ------
    simplex_grid: numpy.ndarray
                  A numpy array of grid points spaced uniformly according to the
                  specifications above.
    """
    def kernel(num: int, terms: int) -> List[Tuple]:
        """
        Recursive kernel function. This computes the set of "compositions" of
        the number `num` with exactly `terms-1` terms.

        For example, the ways to write the number 4 as a sum of 3 nonnegative
        integers are

            0 + 0 + 4 | 1 + 0 + 3 | 2 + 0 + 2 | 3 + 0 + 1 | 4 + 0 + 0 |
            0 + 1 + 3 | 1 + 1 + 2 | 2 + 1 + 1 | 3 + 1 + 0 |
            0 + 2 + 2 | 1 + 2 + 1 | 2 + 2 + 0 |
            0 + 3 + 2 | 1 + 3 + 0 | 
            0 + 4 + 0 |

        This can be generated by running kernel(3, 4).

        Note: The off by one issue is confusing to me but I am trying to avoid
        thinking through the mathematics too carefully.

        Params
        ------
        num:          int
                      The number to be broken down.
        terms:        int
                      The number of integers to break `num` into.

        Returns
        -------
        compositions: list
                      A list of compositions of `num` composed of `terms-1`
                      terms.

        """
        if terms == 0:
            return [(num,)]
        else:
            return [(i, *j) for i in range(num+1) for j in kernel(num-i, terms-1)]


    return np.array(kernel(steps, dimension-1)) / steps
